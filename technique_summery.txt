# A. Uniform group subsampling (Algorithm 1) --- implementation notes

**Goal:** given finite group (G) (represented by its elements and a
generating set (S)), return a subgroup (G\_`\downarrow`{=tex}) that
corresponds to a uniform subsampling by integer factor (R). (Alg.1 in
paper.)

## Data structures

-   Represent group elements as integers or small labels; store group
    multiplication as a function `mul(a,b)` or as a precomputed table
    `mult_table[i,j] -> k`.
-   `G_elems`: list of elements (g_0,`\dots`{=tex},g\_{N-1}) with
    `g_0 = e` (identity).
-   `S = {s1, s2, ...}`: the chosen generating elements (each is an
    element label).
-   `order(s)`: (precomputed) order (o_s) (smallest positive k with
    (s\^k=e)).

## High-level algorithm (direct code mapping of Alg.1)

1.  Build **directed Cayley graph** ( `\mathrm{DiCay}`{=tex}(G,S) ):

    -   Vertex set `V = G_elems`.
    -   For each `v in V` and each generator `s in S`, add directed edge
        `(v, v·s)`.

2.  Choose the generator `s_d` to subsample along (paper gives a
    heuristic later; see §4.1). If you are subsampling by composite `R`,
    factorize `R` and apply sequential subsampling steps using
    generators with large orders. (Alg.2/Alg.3 give checks/heuristic.)

3.  Create a modified edge set `E'`:

    -   For every vertex `v`, remove edge `(v, v·s_d)` and add
        `(v, v·(s_d^R))`. (Use group power `pow(s_d, R)` via repeated
        multiplication or fast exponentiation in group table.)

4.  BFS traversal from identity `e` on graph `(V, E')`:

    -   Start `Q = [e]`, `G_down = {}`.
    -   While queue not empty: pop `n`, add `n` to `G_down`, push
        neighbors `m` reachable from `n` by edges in `E'` that are not
        already visited.
    -   At the end `G_down` is the subgroup returned.

## Implementation notes / complexity

-   Graph creation O(\|V\|\|S\|). BFS O(\|V\|+\|E\|). Alg.2/3 for
    generator selection add loops over `S`, giving worst-case
    O(\|S\|(\|V\|+\|E\|)).
-   Validate Claim 1 conditions (orders divisible by R etc.) --- Alg.2
    gives a graph traversal test to ensure subgroup is proper.

------------------------------------------------------------------------

# B. Equivariant anti-aliasing operator --- step-by-step description

**Goal:** build an anti-aliasing linear operator (P_M) so that: 1. It
enforces bandlimited-ness with respect to a linear map (M) that links
subgroup Fourier coefficients to full-group Fourier coefficients. 2. It
is *equivariant*. 3. It prefers *smooth* basis functions (via a
Laplacian penalty).

This involves solving an optimization (Eq. (14) in the paper) for (M),
then constructing (P_M) from (M).

## Notation and matrix sizes

-   (N = \|G\|) --- full group size.
-   (M_s = \|G\_`\downarrow`{=tex}\|) --- subgroup size.
-   (F_G): Fourier transform matrix of size (N `\times `{=tex}N).
-   (F\_{G`\downarrow`{=tex}}): Fourier matrix for subgroup (M_s
    `\times `{=tex}M_s).
-   `S`: sampling matrix of size (M_s `\times `{=tex}N) selecting
    subgroup elements.
-   `M_mat` (unknown): (N `\times `{=tex}M_s).
-   `B = F_G^{-1} M_mat` ((N `\times `{=tex}M_s)).
-   Projection: (P_M = B (B^`\dagger `{=tex}B)^{-1} B\^`\dagger`{=tex})
    ((N `\times `{=tex}N)).

**Constraint (perfect reconstruction):** \[
F\^{-1}\_{G`\downarrow`{=tex}} = S (F_G\^{-1} M) \] (Eq. 9)

------------------------------------------------------------------------

## Step 1 --- Build primitives

-   Fourier matrices (F_G) and (F\_{G`\downarrow`{=tex}}).
-   Sampling matrix `S`.
-   Graph Laplacian `L` from Cayley graph.
-   Reynolds operator (`\overline{T}`{=tex}) built from group action in
    Fourier domain.

------------------------------------------------------------------------

## Step 2 --- Initialization

Solve least squares: \[ `\min`{=tex}*M \| S (F_G\^{-1} M) -
F*{G`\downarrow`{=tex}}\^{-1} \|\_F\^2 \] This gives an initial
`M_init`.

------------------------------------------------------------------------

## Step 3 --- Optimization objective (Eq. 14)

Two terms: 1. **Equivariance penalty:** \[ \|
`\mathrm{vec}`{=tex}(`\widehat{P_M}`{=tex}) - `\overline{T}`{=tex}
`\mathrm{vec}`{=tex}(`\widehat{P_M}`{=tex}) \|\_2\^2 \] where
(`\widehat{P_M}`{=tex} = F_G P_M F_G\^{-1}).

2.  **Smoothness penalty:** \[
    `\lambda `{=tex}`\mathbf{1}`{=tex}\^`\top `{=tex}`\big`{=tex}(
    `\mathrm{Diag}`{=tex}(F_G\^{-1`\dagger`{=tex}} L F_G\^{-1}) \|M\|
    `\big`{=tex})\^`\top`{=tex} \]

**Constraint:** same as above (perfect reconstruction).

------------------------------------------------------------------------

## Step 4 --- Solve constrained optimization

-   Use SLSQP with equality constraints.
-   Represent complex matrices as real variables (real and imaginary
    parts separately).
-   Add small ridge (`\varepsilon `{=tex}I) to (B\^`\dagger `{=tex}B)
    for stability.
-   Use `M_init` as starting point.
-   Regularization weight (`\lambda`{=tex}) set to 5 in paper.

------------------------------------------------------------------------

## Step 5 --- Construct final anti-aliasing operator

From optimized (M): 1. Compute (B = F_G\^{-1} M). 2. Compute (P_M = B
(B^`\dagger `{=tex}B)^{-1} B\^`\dagger`{=tex}). 3. Use (P_M) to filter
along the group dimension before downsampling.

------------------------------------------------------------------------

## Fourier construction notes

-   **Cyclic groups:** DFT matrix.
-   **Dihedral groups:** known 1D and 2D irreps.
-   **General groups:** build from irreps using Peter--Weyl theorem.

------------------------------------------------------------------------

## Applying in G-CNNs

-   For each spatial position, treat the feature vector along the group
    axis, multiply by (P_M).
-   Then sample subgroup elements to get downsampled representation.

------------------------------------------------------------------------

## Checklist

1.  Implement group structure and Cayley graph.
2.  Select subgroup with Algorithm 1/2/3.
3.  Build Fourier matrices, sampling matrix, Laplacian, Reynolds
    operator.
4.  Initialize `M` via least squares.
5.  Solve constrained optimization (Eq. 14).
6.  Construct (P_M) and integrate into model.
