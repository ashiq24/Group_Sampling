Project: Group_Sampling
Author: Md Ashiqur Rahman

Purpose
- Implements uniform subgroup subsampling for finite groups with an equivariant anti-aliasing operator, aligning with the algorithmic guidance in technique_summery.txt.
- Provides drop-in layers for use in group-equivariant CNNs (via ESCNN), plus a reference G-CNN model and tests.

High-level flow
1) Build Cayley graphs for the group G and subgroup H (GraphConstructor, DihedralGraph, CycleGraph).
2) Compute Fourier bases from irreducible representations (irreps) for G and H.
3) Learn a spectral mapping M (or compute analytically) subject to the perfect reconstruction constraint S·F_G·M ≈ F_H, smoothness, and (optionally) equivariance via a Reynolds-operator-based projector.
4) Form the anti-aliasing projection L1_projector from M’s range to filter signals before subsampling.
5) Perform subgroup sampling and optional upsampling/reconstruction.

---------------------------------------------------------------------
Module: gsampling/utils/graph_constructors.py
Exports
- subsample(group_size, group_type, group_generator, subgroup_type, subsampling_factor)
- class GraphConstructor
- class DihedralGraph
- class CycleGraph

Function: subsample(...)
- Returns the list of node indices selected for the subgroup, given parent group metadata.
- dihedral → dihedral: stride sampling over all nodes (with generator 'r-s').
- dihedral → adihedral: alternate split of rotation/reflection halves (special case branch).
- dihedral → cycle: requires even subsampling_factor; restricts to rotation half and strides there.
- cycle → cycle: simple stride sampling.

Class: GraphConstructor
- Purpose: Given group information, constructs the Cayley graph of the full group G and the subgroup H, including:
  - nodes, edges, adjacency matrices (undirected and directed), a graph-shift/smoother, Fourier basis, and Reynolds operator for equivariance.
- __init__(group_size, group_type, group_generator, subgroup_type, subsampling_factor)
  - Validates compatibility: group_size % subsampling_factor == 0.
  - Builds the parent graph: DihedralGraph (when group_type == 'dihedral') or CycleGraph (when 'cycle'/'cyclic').
  - Selects subgroup nodes via subsample(...).
  - Builds subgroup graph of type CycleGraph (for 'cycle'/'cyclic') or DihedralGraph (for 'dihedral').

Class: DihedralGraph
- Purpose: Represents the Cayley graph for D_n with two common generator conventions ('r-s' or 's-sr').
- Key attributes
  - nodes: integer labels [0, 1, ..., 2n-1]. Assumes even group_size.
  - edges: undirected edges of the Cayley graph (layout depends on generator).
  - adjacency_matrix: |G|×|G| symmetric adjacency.
  - directed_adjacency_matrix: |G|×|G| directed adjacency.
  - edges_generator_1/2 and corresponding directed matrices when generator == 'r-s'.
  - smoother: a stacked/combined directed operator used as a graph shift for spectral smoothness.
  - fourier_basis: |G|×dim(F_G) unitary basis built from irreps of D_n (via ESCNN’s dihedral_group).
  - equi_raynold_op: vectorized Reynolds-operator action constructed from direct-sum irreps (kron of reps).
- Methods
  - __init__(nodes, generator): builds graph structure then Fourier/Reynolds data.
  - _init_edges(group_size, generator): constructs edges/matrices for 'r-s' vs 's-sr' layouts.
  - get_basis(order): stacks irreps across group elements, reshapes to a unitary Fourier basis.
  - get_irreps(order): direct sum of all irreps (with multiplicities) for the action in Fourier domain.
  - get_equi_raynold(order): computes R̄ = (1/|G|) Σ_g ρ(g) ⊗ ρ(g^{-1})^T for the chosen action; returned flattened as a vector operator over vec matrices.

Class: CycleGraph
- Purpose: Cayley graph for C_n (simple cycle).
- Key attributes similar to DihedralGraph but with a single cycle structure.
  - smoother equals directed_adjacency_matrix by default.
  - fourier_basis: regular representation change_of_basis from ESCNN’s cyclic_group.
  - equi_raynold_op: Reynolds operator for C_n (normalized by n).
- Methods
  - get_basis(order): returns F_G from the regular decomposition.
  - get_irreps(order): direct sum of irreps for C_n.
  - get_equi_raynold(order): as above for cyclic groups.

Notes
- These graph classes provide all primitives required by AntiAliasingLayer: adjacency/smoother, Fourier bases, Reynolds operator.

---------------------------------------------------------------------
Module: gsampling/utils/group_utils.py
Exports
- get_group(group_type, order)
- get_gspace(group_type, order, num_features, representation='regular')
- get_sub_group_element(element, group_type, sub_group_type, subsampling_factor)

Functions
- get_group(...): Returns an ESCNN group object: dihedral_group, cyclic_group, or trivial_group.
- get_gspace(...): Returns an ESCNN FieldType (gspace feature type) with regular or trivial representations repeated num_features times. dihedral → flipRot2dOnR2(order), cycle → rot2dOnR2(order).
- get_sub_group_element(...): Maps a parent group element to its representative index in the subgroup after subsampling (used by canonicalization/logic that needs consistent indexing between G and H).

---------------------------------------------------------------------
Module: gsampling/layers/sampling.py
Exports
- class SamplingLayer

Class: SamplingLayer(nn.Module)
- Purpose: Implements subgroup selection for features organized along the group dimension and a pseudoinverse-based upsampling.
- __init__(sampling_factor, nodes, subsample_nodes, type='sample'|'pool')
  - type == 'sample': constructs a sampling_matrix (|H|×|G|) that picks subgroup rows from G; up_sampling_matrix is its pseudoinverse for linear reconstruction to |G|.
  - type == 'pool': uses nn.MaxPool1d with stride==sampling_factor as a trivial pooling alternative.
- forward(x)
  - 1D vector: y = Sx.
  - 4D tensor with channels laid out as (B, C·|G|, H, W): reshapes to (B, C, |G|, H, W), applies S along the group axis, then flattens back.
- up_sample(x)
  - Uses up_sampling_matrix to map (B, C·|H|, H, W) back to (B, C·|G|, H, W) or 1D version.

---------------------------------------------------------------------
Module: gsampling/layers/anti_aliasing.py
Exports
- class AntiAliasingLayer

Class: AntiAliasingLayer(torch.nn.Module)
- Purpose: Learns a spectral operator that enforces bandlimitedness consistent with subgroup sampling and optionally projects to the equivariant subspace. It filters features along the group axis before subgroup sampling to avoid aliasing; also supports upsampling.

Constructor signature (key args)
- nodes, adjaceny_matrix, basis: parent graph nodes, adjacency/shift, Fourier basis Φ_G (|G|×m).
- subsample_nodes, subsample_adjacency_matrix, sub_basis: subgroup data and Fourier basis Φ_H (|H|×n).
- smooth_operator: 'laplacian'|'normalized_laplacian'|'adjacency'|'graph_shift' ⇒ defines L.
- smoothness_loss_weight, iterations, device, dtype.
- raynold_op: Reynolds operator for equivariance constraint.
- equi_constraint (bool): include equivariance loss during learning.
- equi_correction (bool): post-project learned operator to equivariant subspace via Reynolds projector.
- mode: 'linear_optim' (constrained optimization) or 'analytical' (pseudo-inverse solution).
- threshold: sparsify small entries in learned matrices.

Internal buffers and initialization
- smoother: chosen graph frequency operator L (built from adjacency/laplacian/graph_shift).
- basis, sub_basis: registered buffers for Φ_G, Φ_H.
- equi_projector: built from eigenvectors of Reynolds operator with eigenvalue ≈ 1.
- sampling_matrix S: (|H|×|G|) row-selector from subsample_nodes.
- M: learned mapping from G-Fourier to H-Fourier spaces.
- L1_projector: projector onto the range of M (built from eigenvectors of M(MᵀM)⁻¹Mᵀ with eigenvalue ≈ 1).
- up_sampling_basis: Φ_G √|G| · M / √|H| for spectral upsampling after inverse transform.

Key methods
- _init_smooth_selection_operator(...): builds L from A (adjacency) or Laplacian options; supports normalized Laplacian and custom graph-shift.
- _init_raynold_op(raynold_op, dtype): builds equi_projector by eigen-decomposition of Reynolds operator to select invariant subspace.
- _init_anti_aliasing_operator(): learns M via _calculate_M; sparsifies; forms M̄ and L1 eigenspace and projector.
- l1_projector(M: np.ndarray) -> np.ndarray: returns the L1 projector V(VᵀV)⁻¹Vᵀ from eigenvectors of M̄ with eigenvalue ≈ 1.
- equi_correction(operator): applies equi_projector to flatten(operator) then reshapes.
- _calculate_M(...)
  - mode=='analytical': M = pinv(S Φ_G) Φ_H (solves equality exactly without smoothness/equivariance terms).
  - mode=='linear_optim': Uses SciPy minimize with LinearConstraint to enforce S Φ_G M ≈ Φ_H (with small tolerance F0), and objective combining:
    - smoothness_ob1: encourages low spectral energy under L: FB = Φ_G √|G|, shift_err = diag(FBᵀ(FB - L·FB)), penalizes |shift_err @ |M||.
    - equivarinace_loss: ||R·vec(L1) − vec(L1)||₂ for Reynolds R and current L1 from M.
- _forward_f_transform(x, basis) / _inverse_f_transform(x, basis): graph Fourier/inverse transforms handling real/complex dtype and (B,C,|G|,H,W) layout.
- fft/ifft: convenience wrappers using Φ_G.
- anti_aliase(x): FFT → L1 projection → IFFT; works on (B,C·|G|,H,W) or 1D signals; returns same shape as input.
- apply_subsample_matrix(x): returns Sx for 1D signals.
- up_sample(x): (B,C·|H|,H,W) → Fourier on H → spectral lift via up_sampling_basis → inverse transform to (B,C·|G|,H,W).
- forward(x): calls anti_aliase(x).

Usage
- Place before SamplingLayer to filter signals along group dimension; use up_sample for reconstruction from subgroup features.

---------------------------------------------------------------------
Module: gsampling/layers/cannonicalizer.py
Exports
- class Cannonicalizer

Class: Cannonicalizer(nn.EquivariantModule)
- Purpose: Canonicalization following “Group Equivariant Subsampling” (Xu et al.). For each input, selects a representative group element (coset rep) by locating the dominant entry per fiber and transforms the fiber to a canonical pose.
- __init__(group, nodes_num, subgroup, sub_nodes_num, in_channels, dtype, device)
  - Instantiates an ESCNN gspace (flipRot2dOnR2 for dihedral with order/2; rot2dOnR2 for cycle) with regular representation repeated in_channels times.
- coset_rep_r2(x)
  - Input x shape: (B, |G|·C, H, W). Extracts first |G| channels (one fiber), flattens per sample, finds argmax index v.
  - Maps v to a subgroup element index, respecting group/subgroup pair:
    - dihedral→dihedral, cycle→cycle, dihedral→cycle cases handled.
  - Returns a list of coset representatives per batch sample.
- coset_rep(x)
  - Vector version for 1D signals over the group.
- forward(x, coset_rep=None, mode='forward'|'backward')
  - forward: computes v via coset_rep_*; transforms each sample by the inverse of v to canonicalize; returns (result, v) and caches v.
  - backward: applies the stored v (or provided) to map back to the original pose.

---------------------------------------------------------------------
Module: gsampling/layers/downsampling.py
Exports
- class SubgroupDownsample

Class: SubgroupDownsample(nn.Module)
- Purpose: End-to-end group-to-subgroup downsampling module with optional canonicalization and equivariant anti-aliasing.
- __init__(group_type, order, sub_group_type, subsampling_factor, num_features,
          generator='r-s', device='cpu', dtype=torch.float32, sample_type='sample',
          apply_antialiasing=False, anti_aliasing_kwargs=None, cannonicalize=False)
  - Initializes ESCNN groups G and H (sub_order computed from order and factor, accounting for dihedral→cycle mapping).
  - Builds GraphConstructor for G and H.
  - Builds SamplingLayer with sampling_matrix S and pseudoinverse for upsampling.
  - Optionally builds AntiAliasingLayer with graph primitives (adjacency, smoother, Φ_G, Φ_H, Reynolds op).
  - Optionally builds Cannonicalizer.
- forward(x)
  - If canonicalize: (x, v) = Canonicalizer(x), else v=[(-1,-1)].
  - If anti-aliasing: x = AntiAliasingLayer(x).
  - x = SamplingLayer(x).
  - Returns (x, v) with x shape matching subgroup channels.
- upsample(x)
  - Uses AntiAliasingLayer.up_sample if available; else uses SamplingLayer.up_sample (pseudoinverse-based).

---------------------------------------------------------------------
Module: gsampling/layers/rnconv.py
Exports
- class rnConv

Class: rnConv(nn.Module)
- Purpose: Thin wrapper around ESCNN’s R2Conv to accept/return regular PyTorch tensors, while constructing appropriate FieldTypes for input/output.
- __init__(in_group_type, in_order, in_num_features, in_representation,
          out_group_type, out_num_features, out_representation,
          domain=2, kernel_size=3, layer_kwargs={})
  - Builds input/output FieldTypes via get_gspace(...), then enn.R2Conv with padding=(k−1)//2.
  - domain==2 supported.
- forward(x)
  - Wraps x as GeometricTensor with input FieldType, applies R2Conv, returns .tensor of output.

---------------------------------------------------------------------
Module: gsampling/models/g_cnn.py
Exports
- class Gcnn

Class: Gcnn(nn.Module)
- Purpose: Reference hierarchical group-equivariant CNN integrating rnConv, spatial blur pooling, and group downsampling with optional anti-aliasing/canonicalization.
- __init__(num_layers, num_channels, kernel_sizes, num_classes,
          dwn_group_types, init_group_order, spatial_subsampling_factors,
          subsampling_factors, domain, pooling_type, apply_antialiasing,
          canonicalize, antialiasing_kwargs, dropout_rate,
          fully_convolutional=False, layer_kwargs={})
  - For each layer i:
    - Representation: trivial for i==0 else regular.
    - rnConv: in/out FieldTypes based on dwn_group_types[i][0].
    - Spatial downsampling: BlurPool2d(channels=out_channels*|G_i|, stride=spatial_factor_i) if factor>1 else Identity.
    - Group downsampling: SubgroupDownsample(...) if subsampling_factors[i] > 1 else None. Tracks current_group_order.
  - last_g_size: |G_last| for pooling reshape.
  - dropout_layer and linear_layer for classification (skipped if fully_convolutional).
- pooling(x)
  - Reshapes to (B, C, |G|·H·W), applies max/mean over last dim.
- get_feature(x)
  - Runs all layers including optional spatial and group subsampling; returns pooled feature before final linear.
- get_hidden_feature(x)
  - Returns feature tensors before/after each sampling layer and the sampling layer modules (for analysis/visualization).
- forward(x)
  - Returns logits (or feature if fully_convolutional True then linear skipped as configured).

---------------------------------------------------------------------
Module: gsampling/models/model_handler.py
Exports
- get_model(...)

Function: get_model(...)
- Convenience factory that sets sensible defaults, composes a Gcnn with provided lists (channels, kernel sizes, group types, subsampling/spatial factors, anti-aliasing parameters, etc.).

---------------------------------------------------------------------
Module: gsampling/thirdparty/blurpool2d.py
Exports
- class BlurPool2d
- class BlurPool2dMod

Class: BlurPool2d(nn.Module)
- Purpose: Anti-aliased spatial downsampling using a binomial blur kernel (shift-invariant downsampling).
- __init__(channels, filt_size=3, stride=2)
  - Precomputes a separable binomial filter of size 3 or 5, repeats over channels; symmetric padding via get_padding.
- forward(x)
  - Pads and applies grouped 2D convolution with stride.

Class: BlurPool2dMod(nn.Module)
- Variation with simple half-kernel symmetric padding ((filt_size−1)//2) instead of get_padding.

---------------------------------------------------------------------
Module: gsampling/thirdparty/padding.py
Exports
- get_padding(kernel_size, stride=1, dilation=1, ...)
- get_same_padding(x, kernel_size, stride, dilation)
- is_static_pad(kernel_size, stride=1, dilation=1, ...)
- pad_same_arg(input_size, kernel_size, stride, dilation=(1,1))
- pad_same(x, kernel_size, stride, dilation=(1,1), value=0)
- get_padding_value(padding, kernel_size, **kwargs)

- Utility helpers for static/dynamic SAME padding calculations and convenience wrappers used by BlurPool2d.

---------------------------------------------------------------------
Package inits
- gsampling/__init__.py: empty (package marker).
- gsampling/layers/__init__.py: empty.
- gsampling/models/__init__.py: empty.
- gsampling/utils/__init__.py: empty.
- gsampling/thirdparty/__init__.py: empty.

---------------------------------------------------------------------
Module: data/loaders/mri_3d_loader.py
Exports
- class Synthetic3DMRIDataset
- class Real3DMRIDataset
- get_3d_mri_dataloader(...)

Class: Synthetic3DMRIDataset(Dataset)
- Purpose: Generates synthetic 3D MRI-like volumes for testing 3D equivariant models (octahedral context mentioned in docstring but generic generation).
- __init__(num_samples=1000, volume_size=(64,64,64), num_classes=10, noise_level=0.1, include_rotation_augmentation=True, device='cpu')
  - Creates volumes with brain-like structures (ellipsoid cortex/white matter, ventricles, optional lesions), adds noise and normalization, auto-labels based on intensity statistics.
- __len__/__getitem__
  - Returns (1×D×H×W volume, class label). Optional simple rotation augmentation placeholder.

Class: Real3DMRIDataset(Dataset)
- Purpose: Loads NIfTI volumes from a directory; normalizes and resizes; falls back to synthetic if none found.
- __init__(data_dir, target_size=(64,64,64), normalize=True, cache_data=False)
- __len__/__getitem__
  - Loads nibabel NIfTI files, resizes with trilinear interpolation, caches if enabled; dummy labels.

Function: get_3d_mri_dataloader(...)
- Convenience creator for DataLoader for either synthetic or real datasets; prints summary.

Package init: data/__init__.py re-exports Synthetic3DMRIDataset, Real3DMRIDataset, get_3d_mri_dataloader.

---------------------------------------------------------------------
Tests
- tests/layer_tester.py
  - layer_tester_rn(downsampling_layer, spatial_size=[32,32], padding=10): smoke-checks equivariant shapes before/after downsampling/upsampling under group actions.
  - TestLayer.test_functionality: constructs a dihedral→dihedral SubgroupDownsample with anti-aliasing and runs layer_tester_rn.

- tests/model_tester.py
  - TestGcnnModel.test_model_creation: builds default model, checks output/logit shape and pooled feature width; also tests alternate downsampling sequence (dihedral→cycle then cycle→cycle).

- tests/test_claim_2.py
  - test_bandlimited_claim(...): constructs GraphConstructor and AntiAliasingLayer; projects random signals to be bandlimited via anti_aliase; checks reconstruction error after sampling and upsampling; reports mean error over 100 trials.
  - TestReconstructionError.test_reconstruction: multiple parameterizations (dihedral→dihedral, dihedral→cycle, cycle→cycle) verifying small reconstruction error (< 1e-4) with linear optimization.

---------------------------------------------------------------------
Setup and metadata
- setup.py: setuptools configuration for the gsampling package; reads install requirements from requirements.txt; Python ≥ 3.8.
- README.md: overview, badges, installation, quick usage for layer and whole-model integration, teaser figures.

---------------------------------------------------------------------
How implementation maps to technique_summery.txt
- A. Uniform group subsampling (Alg.1/2/3):
  - Cayley graph construction: DihedralGraph/CycleGraph build directed and undirected adjacency and edges following chosen generators; subsample(...) defines R-factor vertex selection per case.
  - BFS/graph traversal from technique summary notion is implicit in building sampling sets; here, subgroup elements are selected by arithmetic strides with correctness checks (assertions) mirroring divisibility constraints.
- B. Equivariant anti-aliasing operator (Eq. 9, 14):
  - Fourier matrices: basis and sub_basis from irreps (get_basis for each graph).
  - Sampling matrix S: built from subsample_nodes in AntiAliasingLayer and SamplingLayer.
  - Smoothness/Laplacian: _init_smooth_selection_operator uses A, L, normalized L, or custom graph shift.
  - Reynolds operator and projector: get_equi_raynold in graph classes; _init_raynold_op computes eigen-based projector onto the equivariant subspace.
  - Initialization/Optimization for M: analytical pinv solution, or constrained minimize with linear equality S·Φ_G·M ≈ Φ_H and objective combining smoothness and equivariance penalties.
  - Projection P_M / L1_projector: M̄ = M(MᵀM)⁻¹Mᵀ; eigenvectors with eigenvalue≈1 define projection; applied in anti_aliase prior to sampling.
  - Upsampling: uses up_sampling_basis = Φ_G √|G| M / √|H| to lift subgroup Fourier coefficients to the parent group then inverse-transform.

Conventions and shapes
- Features on groups are arranged as channels grouped by group elements: (B, C·|G|, H, W). Layers reshape to (B, C, |G|, H, W) internally when needed.
- ESCNN groups: dihedral_group(n) has 2n elements; code’s GraphConstructor expects group_size equal to |G|, while ESCNN get_group(order) uses rotation-order for dihedral; SubgroupDownsample accounts for this using order and subsampling_factor when computing sub_order.

Notes and caveats
- The subsample function contains a branch 'adihedral' for dihedral→adihedral; ensure intended semantics and generator constraints when using it.
- AntiAliasingLayer optimization relies on SciPy and NumPy with potentially long runs (iterations can be large); analytical mode provides a fast closed form but without smoothness/equivariance.
- Reynolds operator building uses ESCNN irreps; ensure escnn is installed and versions compatible with cfloat64 when using complex dtypes.

End of document.
