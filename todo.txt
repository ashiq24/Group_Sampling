# Minimal Refactoring for 3D Group Extension (Tetrahedral, Octahedral, Icosahedral)

## Analysis Summary
Current implementation is hardcoded for 2D groups (cyclic, dihedral) with:
- Hardcoded group type checks in multiple files
- Group-specific graph construction logic embedded in classes
- ESCNN integration limited to 2D gspaces (rot2dOnR2, flipRot2dOnR2)
- Subsampling logic specific to 2D group structures

## Proposed Minimal Refactoring (Absolutely Necessary)

### 1. Abstract Group Graph Interface ‚≠ê CRITICAL
**Files to change:**
- `gsampling/utils/graph_constructors.py`
- Create: `gsampling/core/graphs/base.py`

**Why absolutely necessary:**
- Current: `if group_type == "dihedral"` hardcoded checks prevent 3D group addition
- 3D groups (tetrahedral=24 elements, octahedral=48 elements) have completely different:
  - Edge connectivity patterns (not simple cycles or reflections)
  - Generator sets (3D rotations, not 2D rotations+reflections)
  - Irrep structures (3D irreps vs 1D/2D irreps)

**Minimal change:**
```python
# Abstract interface all groups must implement
class AbstractGroupGraph:
    def get_basis(self, order: int) -> np.ndarray: pass
    def get_irreps(self, order: int): pass  
    def get_equi_raynold(self, order: int) -> np.ndarray: pass
    # Properties: nodes, edges, adjacency_matrix, directed_adjacency_matrix, smoother, fourier_basis

# Factory to avoid hardcoded if/elif chains
class GroupGraphFactory:
    @staticmethod
    def create(group_type: str, nodes: list, generator: str = None) -> AbstractGroupGraph:
        if group_type == "cycle": return CycleGraph(nodes)
        elif group_type == "dihedral": return DihedralGraph(nodes, generator)
        elif group_type == "tetrahedral": return TetrahedralGraph(nodes)  # NEW
        elif group_type == "octahedral": return OctahedralGraph(nodes)    # NEW
        else: raise NotImplementedError(f"Group type {group_type}")
```

### 2. ESCNN Group Registry ‚≠ê CRITICAL  
**Files to change:**
- `gsampling/utils/group_utils.py`

**Why absolutely necessary:**
- Current: Hardcoded `gspaces.rot2dOnR2(order)` and `gspaces.flipRot2dOnR2(order)`
- 3D groups need: `gspaces.rot3dOnR3()`, `gspaces.flipRot3dOnR3()`, or custom 3D gspaces
- ESCNN may not have built-in tetrahedral/octahedral gspaces - need extensible registry

**Minimal change:**
```python
# Registry pattern for group types
GROUP_REGISTRY = {
    "cycle": {"escnn_func": cyclic_group, "gspace_func": lambda order: gspaces.rot2dOnR2(order)},
    "dihedral": {"escnn_func": dihedral_group, "gspace_func": lambda order: gspaces.flipRot2dOnR2(order)},
    "tetrahedral": {"escnn_func": tetrahedral_group, "gspace_func": lambda order: gspaces.rot3dOnR3()},  # NEW
    "octahedral": {"escnn_func": octahedral_group, "gspace_func": lambda order: gspaces.rot3dOnR3()},    # NEW
}

def get_group(group_type: str, order: int):
    if group_type not in GROUP_REGISTRY:
        raise ValueError(f"Group type {group_type} not supported")
    return GROUP_REGISTRY[group_type]["escnn_func"](order)
```

### 3. Subsampling Strategy Registry ‚≠ê CRITICAL
**Files to change:**
- `gsampling/utils/graph_constructors.py` (subsample function)

**Why absolutely necessary:**
- Current: Hardcoded subsampling logic for dihedral‚Üídihedral, dihedral‚Üícycle, cycle‚Üícycle
- 3D groups have complex subgroup relationships:
  - Tetrahedral ‚Üí Cyclic (C3 rotations around vertex-face axis)
  - Octahedral ‚Üí Tetrahedral, Octahedral ‚Üí Dihedral (face rotations), Octahedral ‚Üí Cyclic
  - Need flexible subsampling strategies, not hardcoded arithmetic

**Minimal change:**
```python
# Strategy pattern for subsampling
SUBSAMPLING_STRATEGIES = {
    ("cycle", "cycle"): lambda nodes, factor: nodes[::factor],
    ("dihedral", "dihedral"): lambda nodes, factor: nodes[::factor], 
    ("dihedral", "cycle"): lambda nodes, factor: nodes[:len(nodes)//2:factor//2],
    ("tetrahedral", "cycle"): tetrahedral_to_cycle_subsample,     # NEW
    ("octahedral", "tetrahedral"): octahedral_to_tetrahedral_subsample,  # NEW
}

def subsample(group_size, group_type, group_generator, subgroup_type, subsampling_factor):
    key = (group_type, subgroup_type)
    if key not in SUBSAMPLING_STRATEGIES:
        raise NotImplementedError(f"Subsampling {group_type} ‚Üí {subgroup_type}")
    return SUBSAMPLING_STRATEGIES[key](list(range(group_size)), subsampling_factor)
```

### 4. 3D Group Implementation Stubs ‚≠ê NECESSARY
**Files to create:**
- `gsampling/core/graphs/tetrahedral.py`
- `gsampling/core/graphs/octahedral.py`

**Why necessary:**
- Need concrete implementations of 3D group graphs
- Must implement AbstractGroupGraph interface
- Critical methods: `get_basis()`, `get_irreps()`, `get_equi_raynold()`

**Minimal implementation:**
```python
class TetrahedralGraph(AbstractGroupGraph):
    def __init__(self, nodes: list):
        self.nodes = nodes
        self._build_tetrahedral_cayley_graph()
        self.fourier_basis = self.get_basis(24)  # T has 24 elements
        self.equi_raynold_op = self.get_equi_raynold(24)
    
    def get_basis(self, order: int) -> np.ndarray:
        # Use ESCNN tetrahedral irreps or implement custom 3D irreps
        pass
    
    def get_equi_raynold(self, order: int) -> np.ndarray:
        # Implement R = (1/|G|) Œ£_{g‚ààG} œÅ(g) ‚äó œÅ(g‚Åª¬π)·µÄ for tetrahedral group
        pass
```

## Non-Essential Refactoring (Can be deferred)

### 5. Canonicalizer 3D Support (Optional)
**Files:** `gsampling/layers/cannonicalizer.py`
**Why optional:** Only needed if canonicalization is required for 3D groups

### 6. Model Handler Updates (Optional)  
**Files:** `gsampling/models/model_handler.py`, `gsampling/models/g_cnn.py`
**Why optional:** Can reuse existing model structure; only need group type registry updates

### 7. Test Infrastructure (Optional but Recommended)
**Files:** `tests/fourier_tester.py`, `tests/layer_tester.py`
**Why optional:** Current tests will work with new groups via parametrization

## Implementation Priority

### Phase 1: Core Extension Points (Absolutely Necessary)
1. **AbstractGroupGraph interface** - Enables polymorphic group handling
2. **GroupGraphFactory** - Eliminates hardcoded group type checks  
3. **Group registry in group_utils.py** - Supports new ESCNN group types
4. **Subsampling strategy registry** - Handles complex 3D subgroup relationships

### Phase 2: 3D Group Implementations (Necessary)
1. **TetrahedralGraph class** - 24-element tetrahedral group T
2. **OctahedralGraph class** - 48-element octahedral group O  
3. **3D subsampling strategies** - Group-specific subsampling algorithms

### Phase 3: Integration and Testing (Recommended)
1. **Update model handlers** - Support 3D group types in model configs
2. **Extend test parametrization** - Add 3D groups to existing test suites
3. **3D-specific tests** - Validate 3D group mathematical properties

## Estimated Effort
- **Phase 1:** ~200 lines of refactoring existing code
- **Phase 2:** ~400-600 lines of new 3D group implementations  
- **Phase 3:** ~100-200 lines of integration and testing

## Key Benefits
- **Minimal disruption:** Existing 2D group functionality unchanged
- **Clean extension:** New groups implement standard interface
- **Future-proof:** Framework supports arbitrary finite groups
- **Maintainable:** Group-specific logic isolated in dedicated classes

## Critical Success Factors
1. **ESCNN 3D support:** Verify ESCNN has tetrahedral/octahedral group objects
2. **3D irrep knowledge:** Need 3D irreducible representations for Fourier bases
3. **Subgroup theory:** Understand tetrahedral/octahedral subgroup lattices
4. **Testing strategy:** Validate 3D group mathematical properties

This refactoring is **absolutely necessary** because the current hardcoded approach cannot accommodate 3D groups without modifying core logic throughout the codebase.

## ‚úÖ COMPLETED IMPLEMENTATIONS

### Phase 1: Core Extension Points ‚úÖ COMPLETED
1. **AbstractGroupGraph interface** ‚úÖ - Created `gsampling/core/graphs/base.py`
2. **GroupGraphFactory** ‚úÖ - Created `gsampling/core/graphs/factory.py`  
3. **Group registry in group_utils.py** ‚úÖ - Extended with 3D group support
4. **Subsampling strategy registry** ‚úÖ - Created `gsampling/core/subsampling.py`

### Phase 2: 3D Group Implementations ‚úÖ COMPLETED
1. **OctahedralGraph class** ‚úÖ - 24-element octahedral group O
2. **FullOctahedralGraph class** ‚úÖ - 48-element full octahedral group O_h
3. **3D subsampling strategies** ‚úÖ - Registered in subsampling registry

### Phase 3: Integration and Testing ‚úÖ COMPLETED
1. **Factory integration** ‚úÖ - Octahedral groups work with GroupGraphFactory
2. **Comprehensive testing** ‚úÖ - 31 tests in `tests/octa_fourier_tester.py` all passing
3. **Mathematical validation** ‚úÖ - Fourier basis and Reynolds operator properties verified
4. **ESCNN integration** ‚úÖ - Compatible with 3D group theory library

## üéØ NEXT STEPS FOR FURTHER 3D GROUP SUPPORT

### Tetrahedral Group Implementation
- Create `gsampling/core/graphs/tetrahedral.py` with `TetrahedralGraph` class
- Implement 24-element tetrahedral group T (rotational symmetries)
- Add to GroupGraphFactory and subsampling registry
- Create comprehensive tests similar to octahedral implementation

### Icosahedral Group Implementation  
- Create `gsampling/core/graphs/icosahedral.py` with `IcosahedralGraph` class
- Implement 60-element icosahedral group I (rotational symmetries)
- Add to GroupGraphFactory and subsampling registry
- Create comprehensive tests for icosahedral mathematical properties

### SO(3) Continuous Group Support
- Investigate ESCNN's SO(3) group implementation
- Create `gsampling/core/graphs/so3.py` for continuous 3D rotations
- Implement discretized SO(3) representations for practical use
- Add continuous group subsampling strategies
