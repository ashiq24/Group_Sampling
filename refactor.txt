Refactor plan for Group_Sampling

Goals
- Make it easy to add new groups (beyond cyclic/dihedral) and new functionality without modifying existing code.
- Decouple concerns: group theory primitives, graph construction, spectral bases, anti-aliasing solvers, sampling ops, model wiring.
- Improve reliability, readability, and maintainability with clear interfaces, type hints, and tests.
- Align with ESCNN abstractions and best practices, per their docs: https://quva-lab.github.io/escnn/

Proposed high-level structure
- gsampling/
  - core/
    - groups.py (GroupSpec, SubgroupSpec, mapping constraints, registry)
    - graphs/
      - base.py (AbstractGroupGraph, interfaces)
      - cyclic.py (CycleGraph)
      - dihedral.py (DihedralGraph)
      - factory.py (GraphFactory)
    - fourier/
      - basis.py (BasisProvider, ESCNNBasisProvider)
      - reynolds.py (ReynoldsOperatorBuilder)
      - sampling.py (SamplingMatrixBuilder)
      - smooth_ops.py (AdjacencyOp, LaplacianOp, NormalizedLaplacianOp, CustomShiftOp)
  - aa/ (anti-aliasing)
    - operators.py (AntiAliasingOperator, L1Projector)
    - solvers/
      - base.py (AntiAliasingSolver)
      - analytical.py (AnalyticalSolver)
      - linear_opt.py (LinearOptimizationSolver)
    - config.py (dataclasses for AA config)
  - sampling/
    - sampling_layer.py (SamplingLayer)
    - strategies.py (SampleStrategy, PoolStrategy, future: AverageStrategy, LearnedPoolStrategy)
  - canonical/
    - canonicalizer.py (renamed from cannonicalizer.py)
  - layers/
    - rnconv.py
    - downsample.py (renamed from downsampling.py, composes sampling + optional AA + canonicalizer)
  - models/
    - g_cnn.py
    - model_handler.py
  - utils/
    - tensor_layout.py (reshape helpers B,C*|G|,H,W ↔ B,C,|G|,H,W)
    - validation.py (assertions and friendly errors)
    - registry.py (simple plugin registry helpers)
    - logging.py (project-level logging config)
  - vendor/
    - blurpool2d.py
    - padding.py

Key changes (what / how / why)
1) Introduce AbstractGroupGraph and GraphFactory
- What: Create core/graphs/base.py with AbstractGroupGraph defining:
  - properties: nodes, edges, adjacency_matrix, directed_adjacency_matrix, smoother
  - methods: build_graph(), get_basis(), get_irreps(), get_reynolds()
  And core/graphs/factory.py with GraphFactory.from_spec(group_type, nodes, generator)
- How: Move current DihedralGraph, CycleGraph into separate files implementing the abstract base. Switch GraphConstructor to use GraphFactory.
- Why: Clear extension point; new groups implement the same interface without touching other code.

2) Replace GraphConstructor with composable Core builders
- What: Split GraphConstructor responsibilities:
  - graphs: GraphFactory
  - fourier: BasisProvider (ESCNN backed), ReynoldsOperatorBuilder
  - sampling: SamplingMatrixBuilder
- How: core/fourier/basis.py uses ESCNN dihedral_group/cyclic_group to build Φ; core/fourier/reynolds.py builds R via direct-sum irreps; core/fourier/sampling.py builds S from nodes and subsample_nodes.
- Why: Single-responsibility components are easier to test, reuse, and extend (e.g., alternative basis providers).

3) Anti-aliasing as pluggable pipeline
- What: Introduce aa/operators.py with AntiAliasingOperator encapsulating:
  - config (aa/config.py dataclasses)
  - smoother (core/fourier/smooth_ops.py)
  - M solver (aa/solvers/*)
  - L1 projector
- How: Move _calculate_M to solvers/analytical.py and solvers/linear_opt.py implementing AntiAliasingSolver interface; AntiAliasingOperator composes solver + projectors; expose anti_aliase() and up_sample().
- Why: Swap solvers or add new ones (e.g., PyTorch-based differentiable solver) without touching other code.


5) Sampling strategies and tensor layout utilities
- What: Move SamplingLayer to sampling/sampling_layer.py; introduce strategies.py for alternate sampling behaviors; add utils/tensor_layout.py for consistent reshaping and einsum keys.
- How: SamplingLayer composes a strategy; default SampleStrategy uses S and pinv; PoolStrategy wraps nn.MaxPool1d; future strategies can be added.
- Why: Clean separation of concerns; easier to extend with new sampling behaviors.

6) Centralize group/subgroup metadata and constraints
- What: core/groups.py with GroupSpec, SubgroupSpec, SubsamplingRule; a registry mapping (group_type, subgroup_type) to constraint functions and element-mapping functions (currently get_sub_group_element).
- How: Migrate get_sub_group_element and the divisibility assertions to this module; standardize naming ('cyclic'→'cycle', remove 'adihedral', or document it formally). Provide helpful ValidationError messages.
- Why: Avoid scattering rules across files; easier to add new group pairs safely.

7) Smoothness operators as first-class components
- What: core/fourier/smooth_ops.py with AdjacencyOp, LaplacianOp, NormalizedLaplacianOp, CustomShiftOp; all return torch tensors with dtype/device managed.
- How: Anti-aliasing operator now depends on a SmoothnessOp interface rather than reconstructing matrices internally.
- Why: Reusability and clarity; switching operators becomes trivial.

8) Strong typing, dataclasses, and configuration
- What: Adopt Python type hints across modules; use @dataclass for configs (AAConfig, ModelConfig, GraphSpec). Consider pydantic if runtime validation needed.
- How: Add typing to all public APIs; mypy optional checking; minimal runtime overhead.
- Why: Safer extensions; clearer contracts for contributors.

9) Logging, no prints, and error handling
- What: Replace prints with Python logging; structured, leveled logs (debug/info/warn/error). Raise custom exceptions with actionable hints.
- How: utils/logging.py sets up a logger; modules use getLogger(__name__). Remove interactive prints in optimization paths.
- Why: Cleaner output, production-ready, easier debugging.

10) Device and dtype consistency
- What: Normalize device/dtype handling. All long-lived tensors are registered buffers with correct dtype and device. Explicit conversions are minimized.
- How: Add helper functions to move related buffers together; avoid inadvertent CPU/GPU mixing; standardize complex vs real handling (torch.cfloat/torch.cdouble) consistently.
- Why: Fewer runtime errors; easier to run on CPU/GPU interchangeably.

11) Public API at package root
- What: Add top-level __init__.py exports: GraphFactory, AntiAliasingOperator, SamplingLayer, Canonicalizer, rnConv, SubgroupDownsample (renamed to Downsample), get_model.
- How: Re-export stable interfaces; keep internals private.
- Why: Stable import paths for users and examples.

12) ESCNN integration guidelines and version pin
- What: Document supported ESCNN versions and breaking changes (per docs: kernels refactor, etc.).
- How: Pin escnn>=1.0.<x> in requirements; add README section on ESCNN with link: https://quva-lab.github.io/escnn/
- Why: Avoid runtime mismatches; help users troubleshoot API differences.

13) Project hygiene
- What: Add pre-commit (black, isort, ruff), mypy config, CI workflow, CONTRIBUTING.md, and API docs with mkdocs or Sphinx.
- How: Provide config files and badges; keep style consistent.
- Why: Encourage contributions; maintain quality.

14) Replace magic strings with Enums/Constants
- What: Enums for group types, smooth operators, sampling types, representations.
- How: Define in core/const.py or inside related modules; deprecate raw strings.
- Why: Fewer typos, better auto-complete.

15) Generalize Cayley graph construction
- What: Allow passing arbitrary generator sets for groups; extend GraphFactory to accept generator spec; for new groups, implement adjacency from generators.
- How: GraphSpec(generator_set=...) and group-specific logic to compute edges.
- Why: Supports diverse finite groups without editing existing code paths.

16) Performance and caching
- What: Cache Fourier bases, Reynolds operators, and sampling matrices keyed by GroupSpec/SubgroupSpec; optional LRU.
- How: functools.lru_cache or custom cache in core/fourier/*. Ensure deterministic seeds.
- Why: Reduce recomputation overhead, speed up experiments.

17) Rename and deprecate APIs
- What: downsampling.py → layers/downsample.py; class SubgroupDownsample → Downsample; cannonicalizer.py → canonical/canonicalizer.py.
- How: Provide deprecated wrappers with warnings for one release cycle.
- Why: Clearer naming and structure.

Detailed migration guide (how to)
- Move DihedralGraph, CycleGraph:
  1) Create core/graphs/base.py with AbstractGroupGraph (abc.ABC).
  2) Create core/graphs/dihedral.py and core/graphs/cyclic.py; port code and adapt to base signatures.
  3) Create core/graphs/factory.py to select concrete implementation.
- Split GraphConstructor:
  1) Remove Fourier/Reynolds logic from graph classes; move to core/fourier/basis.py and reynolds.py.
  2) Implement SamplingMatrixBuilder in core/fourier/sampling.py.
  3) Create a thin orchestrator (optional) that composes these builders.
- AntiAliasing refactor:
  1) Create aa/solvers/base.py (fit(FB, F, S, L, R) → M).
  2) analytical.py implements pinv solution; linear_opt.py moves SciPy code.
  3) AntiAliasingOperator holds buffers (Φ_G, Φ_H, S, L, R, M, L1) and exposes forward/upsample.
- Canonicalizer rename and cleanup:
  1) Move to canonical/canonicalizer.py; update imports; add deprecation shim.
  2) Add unit tests for forward/backward consistency.
- Sampling strategies:
  1) sampling/strategies.py with Strategy base, SampleStrategy, PoolStrategy.
  2) sampling_layer.py delegates to strategy.
- Utilities and constants:
  1) utils/tensor_layout.py with reshape helpers and validated einsum strings.
  2) core/groups.py to host get_sub_group_element logic and constraints.
- Replace prints with logging and add type hints across modules.

Why these changes
- Establish stable interfaces for extension points (new groups, new solvers, new sampling strategies) without touching core logic.
- Improve separation of concerns so each piece is small, testable, and replaceable.
- Aligns conceptual layers with ESCNN’s group/gspace/nn split, easing maintenance and onboarding.

Testing plan (expand tests/)
A) Core: graphs and groups
- test_graph_factory.py
  - Build graphs for cyclic and dihedral; validate:
    - node count, edge count symmetry
    - adjacency vs directed adjacency consistency
    - smoother has expected shape and sparsity
- test_fourier_basis.py
  - basis unitary (ΦᵀΦ ≈ I) within tolerance
  - dimensions match |G| and irreps dim sum
- test_reynolds_operator.py
  - R eigenvalues include 1; projector P constructed from |λ−1|<ε is idempotent (P²≈P)

B) Anti-aliasing
- test_aa_analytical_solver.py
  - Check S Φ_G M ≈ Φ_H for multiple groups, dtypes, devices
- test_aa_linear_solver.py
  - Verify objective decreases; equality constraints satisfied
  - With/without equivariance term
- test_aa_operator_end2end.py
  - Bandlimiting then sample+upsample reconstruction error < threshold for various (G→H, factors)
  - Compare Laplacian vs adjacency smooth operators

C) Sampling and strategies
- test_sampling_layer.py
  - sample strategy: S and pinv(S) shapes; forward and upsample round-trip on random signals
  - pool strategy: stride behavior and shape checks

D) Canonicalizer
- test_canonicalizer.py
  - forward then backward recovers original tensor (within tolerance)
  - coset representative mapping rules for all supported group/subgroup pairs

E) Layers and models
- test_downsample_layer.py
  - Compose Canonicalizer + AntiAliasingOperator + SamplingLayer; check shapes, reconstruction, equivariance under group transforms
- test_rnconv_wrapper.py
  - Verify input/output shapes; gradient flows
- test_gcnn_integration.py
  - Instantiate various configs; run forward; check output shapes; optionally small training step to test backward

F) Data loaders
- test_mri_3d_loader.py
  - Synthetic: dataset length, item shapes, normalization stats sane
  - Real: fallback path when empty dir; resize correctness

G) Utilities and validation
- test_tensor_layout.py
  - Reshape round-trips; einsum correctness on small random tensors
- test_validation_errors.py
  - Invalid configs raise clear exceptions with actionable messages

H) Cross-device/dtype matrix
- Parametrize critical tests over device={cpu,cuda (if available)}, dtype={float32,float64,cfloat,cdouble}

I) Random seeds and determinism
- Ensure tests set seeds where appropriate; validate caches don’t change results across calls

J) Coverage for ESCNN integration
- Smoke tests use escnn.gspaces and nn.FieldType/GeometricTensor per docs: https://quva-lab.github.io/escnn/

Additional housekeeping tests
- Lint and type check gates in CI (black, isort, ruff, mypy) must pass
- Import surface tests to ensure stable public API

Migration and deprecation tests
- Ensure deprecated paths (old filenames/classes) import with DeprecationWarning and behave identically for one release cycle

Documentation tasks
- Update README with new architecture overview, extension guide (add a new group in N steps), and ESCNN version notes (link: https://quva-lab.github.io/escnn/)
- Add examples for: adding a new group, plugging a new AA solver, adding a sampling strategy

End of plan.
