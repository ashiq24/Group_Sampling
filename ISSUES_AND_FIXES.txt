# ISSUES AND FIXES ANALYSIS
# =========================

## CURRENT STATUS
- ACDC Segmentation Pipeline: ‚úÖ WORKING with group downsampling + anti-aliasing enabled
- OrganMNIST3D Classification Pipeline: ‚úÖ WORKING with group downsampling + anti-aliasing enabled
- Both pipelines now fully functional with C4 cyclic subgroup (order 4) for 90-degree rotations around z-axis

## ROOT CAUSE ANALYSIS

### 1. TENSOR SIZE MISMATCH ISSUE
**Error**: `AssertionError: Error! The size of the tensor torch.Size([2, 512, 7, 7, 7]) does not match the size of the field type 128.`

**Analysis**:
- Expected: 128 channels (4 * 32) after group downsampling from octahedral (24) to cycle (6) with factor 6
- Actual: 512 channels (16 * 32) - group downsampling is NOT being applied correctly
- This suggests the group downsampling layer is either not being created or not being applied in the forward pass

### 2. ARCHITECTURAL ISSUES IDENTIFIED

#### A. Group Downsampling Layer Creation
- In `g_cnn_3d.py` line 116-131: Group downsampling layer is created correctly
- Configuration shows: `subsampling_factors: [1, 1, 6, 1]` - layer 2 should downsample
- Layer 2 should go from octahedral (24) to cycle (6) with factor 6

#### B. Forward Pass Order Issue
- In `g_cnn_3d.py` line 192-200: Forward pass applies group downsampling AFTER convolution
- This is correct order: conv ‚Üí spatial downsampling ‚Üí group downsampling
- But the group downsampling might not be reducing channels correctly

#### C. Group Order Tracking Issue
- In `g_cnn_3d.py` line 164-165: `current_group_order` is updated after group downsampling
- This should track the group order changes correctly
- But there might be a mismatch between expected and actual group orders

### 3. CONFIGURATION ANALYSIS

#### OrganMNIST3D Configuration:
```yaml
group_config:
  init_group_order: 24        # Octahedral group
  dwn_group_types: [
    ["octahedral", "octahedral"],  # Layer 1: No group downsampling
    ["octahedral", "octahedral"],  # Layer 2: No group downsampling  
    ["octahedral", "cycle"],       # Layer 3: O ‚Üí C6
    ["cycle", "cycle"]             # Layer 4: C6 ‚Üí C6
  ]
  subsampling_factors: [1, 1, 6, 1]      # Group subsampling ratios
```

**Issue**: Layer 2 has `subsampling_factors[1] = 1` but `dwn_group_types[1] = ["octahedral", "octahedral"]`
- This means layer 2 should NOT do group downsampling
- But the error occurs at layer 2, suggesting the issue is elsewhere

### 4. KEY INSIGHTS

#### A. Group Downsampling Logic
- The `SubgroupDownsample` layer should reduce channels from `C * |G_in|` to `C * |G_out|`
- For octahedral (24) ‚Üí cycle (6) with factor 6: `C * 24` ‚Üí `C * 4` (not `C * 6`)
- The issue might be in how the subgroup order is calculated

#### B. Channel Calculation
- Input: 32 channels * 24 (octahedral) = 768 channels
- After conv: 64 channels * 24 (octahedral) = 1536 channels  
- After group downsampling: 64 channels * 4 (cycle) = 256 channels
- But we're getting 512 channels (16 * 32), suggesting the group downsampling is not working

#### C. Anti-aliasing Integration
- The anti-aliasing layer might be interfering with the group downsampling
- Or there might be a bug in the anti-aliasing implementation that's causing channel mismatches

## PROPOSED SOLUTION STRATEGY

### Phase 1: Simple Model Testing
1. Create minimal test models without group downsampling
2. Verify basic forward/backward pass works
3. Test with simple group configurations

### Phase 2: Group Downsampling Debugging
1. Test group downsampling layer in isolation
2. Verify channel reduction is working correctly
3. Test with different group configurations

### Phase 3: Integration Testing
1. Test full model with group downsampling enabled
2. Verify forward pass works correctly
3. Test backward pass and training

### Phase 4: End-to-End Pipeline Testing
1. Test classification pipeline with group downsampling
2. Test segmentation pipeline with group downsampling
3. Verify both work with anti-aliasing enabled

## CRITICAL FILES TO EXAMINE
- `models/g_cnn_3d.py`: Main 3D model architecture
- `gsampling/layers/downsampling.py`: Group downsampling implementation
- `gsampling/layers/sampling.py`: Sampling layer implementation
- `config/organmnist3d_config.yaml`: Classification configuration
- `config/acdc.yaml`: Segmentation configuration

## EXPECTED OUTCOMES
- Both classification and segmentation pipelines working with group downsampling + anti-aliasing
- Proper channel reduction in group downsampling layers
- Correct group order tracking throughout the network
- Stable training and evaluation

## CRITICAL TESTING REQUIREMENT
**‚ö†Ô∏è IMPORTANT: Whenever updating anything in @gsampling/ folder, ALWAYS run required tests from @tests/ to ensure we don't break existing functionality.**

Required tests to run after @gsampling/ changes:
- `python tests/3d_claim_2.py` - Test 3D bandlimited reconstruction claims
- `python tests/fourier_tester.py` - Test Fourier transform functionality  
- `python tests/test_3d_downsampling.py` - Test 3D downsampling functionality
- `python tests/test_3d_convolution.py` - Test 3D convolution functionality

## CODE DOCUMENTATION REQUIREMENTS
**üìù IMPORTANT: Add sufficient comments inside the code so that you can understand what is done later.**

### Required Documentation Standards:
1. **Mathematical Explanations**: Provide clear mathematical explanations for all group operations
2. **Equations**: Write out the key mathematical equations used in the code
3. **Code Comments**: Add detailed comments explaining:
   - What each function does
   - Why specific calculations are performed
   - How group downsampling works mathematically
   - What the sampling matrices represent
4. **Group Theory Context**: Explain the group theory behind the operations
5. **Implementation Details**: Document any non-obvious implementation choices

### Key Mathematical Concepts to Document:
- **Group Downsampling**: S: L¬≤(G) ‚Üí L¬≤(H) via S = Œ†_H‚àòR_G
- **Sampling Matrix**: Maps from main group G to subgroup H
- **Channel Reduction**: C * |G| ‚Üí C * |H| where |H| = |G| / subsampling_factor
- **Anti-aliasing**: XÃÉ = L1_projector¬∑XÃÇ before subsampling
- **Group Order Calculation**: How subgroup orders are computed for different group types

## FINAL RESOLUTION SUMMARY

### ‚úÖ ALL ISSUES RESOLVED

**Problem**: Both classification and segmentation pipelines were failing with group downsampling and anti-aliasing enabled.

**Root Cause**: Incorrect subgroup order calculation and improper group order tracking throughout the network.

**Solution Implemented**:

1. **C4 Cyclic Subgroup Support**: 
   - Updated `gsampling/utils/graph_constructors.py` to use `subsample_with_strategy` for correct C4 subgroup identification (order 4)
   - This enables 90-degree rotations around the z-axis as specifically requested by the user

2. **Hybrid Layer Architecture**:
   - Created `HybridConvGroupResample3D` in `models/hybrid.py` that combines `rnConv` (maintains group order) with `SubgroupDownsample` (changes group order)
   - This allows seamless group transitions while maintaining the strict in/out order requirement of `rnConv`

3. **Model Architecture Updates**:
   - Modified `models/g_cnn_3d.py` to use `HybridConvGroupResample3D` for all layers after the first
   - Fixed group order tracking throughout the network to ensure spatial pooling layers use correct group order
   - Updated `models/g_cnn_3d_seg.py` for 4D U-Net segmentation with proper group and spatial downsampling/upsampling

4. **Mathematical Documentation**:
   - Added comprehensive mathematical explanations and equations throughout the codebase
   - Documented group theory concepts, sampling matrices, and channel reduction formulas
   - Added detailed comments explaining the implementation choices

**Final Status**: ‚úÖ **ALL SYSTEMS OPERATIONAL**
- Classification pipeline: ‚úÖ Working with group downsampling + anti-aliasing
- Segmentation pipeline: ‚úÖ Working with group downsampling + anti-aliasing  
- C4 cyclic subgroup (order 4): ‚úÖ Correctly implemented for 90-degree rotations around z-axis
- Both pipelines support GPU training, checkpointing, and evaluation-only mode
- All tensor shape mismatches and interpolation issues resolved
